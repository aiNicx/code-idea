/**
 * Sistema di documentazione tecnica modulare
 * Supporta plugin per diversi framework e backend
 */

import type {
  TechDocSection,
  TechDocTemplate,
  TechDocContext,
  TechDocPlugin,
  TechDocRenderer
} from '../models/techDocumentation';
import { techDocCache } from './cache';

export class TechDocRendererImpl implements TechDocRenderer {
  renderSection(section: TechDocSection, context: TechDocContext): string {
    let content = section.content;

    // Sostituisci variabili nel contenuto
    Object.entries(context).forEach(([key, value]) => {
      const regex = new RegExp(`\\$\\{${key}\\}`, 'g');
      content = content.replace(regex, String(value));
    });

    return `## ${section.title}

${content}

*Tags: ${section.tags.join(', ')}*
${section.prerequisites ? `*Prerequisites: ${section.prerequisites.join(', ')}*` : ''}`;
  }

  renderTemplate(template: TechDocTemplate, context: TechDocContext): string {
    let content = `# ${template.name}

${template.description}

`;

    // Qui andrebbero caricate le sezioni del template
    // Per ora Ã¨ un placeholder
    content += `\n*Generated for ${context.framework} + ${context.backend}*\n`;

    return content;
  }

  renderCombined(sections: TechDocSection[], context: TechDocContext): string {
    const renderedSections = sections.map(section =>
      this.renderSection(section, context)
    );

    return `# Technical Documentation

*Generated for: ${context.framework} + ${context.backend}*

---

${renderedSections.join('\n\n---\n\n')}

---
*Generated by TechDoc System*`;
  }
}

export class TechDocPluginManager {
  private plugins = new Map<string, TechDocPlugin>();
  private renderer = new TechDocRendererImpl();

  registerPlugin(plugin: TechDocPlugin): void {
    this.plugins.set(plugin.name, plugin);
    console.log(`[TechDoc] Registered plugin: ${plugin.name} v${plugin.version}`);
  }

  async getSections(context: TechDocContext): Promise<TechDocSection[]> {
    const allSections: TechDocSection[] = [];

    for (const plugin of this.plugins.values()) {
      // Controlla se il plugin supporta il framework e backend
      if (plugin.supportedFrameworks.includes(context.framework) &&
          plugin.supportedBackends.includes(context.backend)) {
        try {
          const sections = await plugin.getSections(context);
          allSections.push(...sections);
        } catch (error) {
          console.warn(`[TechDoc] Plugin ${plugin.name} failed to load sections:`, error);
        }
      }
    }

    return allSections;
  }

  async getTemplates(context: TechDocContext): Promise<TechDocTemplate[]> {
    const allTemplates: TechDocTemplate[] = [];

    for (const plugin of this.plugins.values()) {
      if (plugin.supportedFrameworks.includes(context.framework) &&
          plugin.supportedBackends.includes(context.backend)) {
        try {
          const templates = await plugin.getTemplates(context);
          allTemplates.push(...templates);
        } catch (error) {
          console.warn(`[TechDoc] Plugin ${plugin.name} failed to load templates:`, error);
        }
      }
    }

    return allTemplates;
  }

  async renderDocumentation(context: TechDocContext): Promise<string> {
    const cacheKey = techDocCache.constructor.prototype.generateKey.call(techDocCache, context);

    // Controlla cache
    const cached = techDocCache.get(cacheKey);
    if (cached) {
      techDocCache.recordHit();
      return cached;
    }

    techDocCache.recordMiss();

    // Carica sezioni
    const sections = await this.getSections(context);

    // Renderizza
    const rendered = this.renderer.renderCombined(sections, context);

    // Cache il risultato
    techDocCache.set(cacheKey, rendered);

    return rendered;
  }
}

// Singleton instance
export const techDocPluginManager = new TechDocPluginManager();